h1. Tabula Rasa

Tabula Rasa provides support for user-customisable tables, allowing each user to have a custom view of any table in your application.  Client-side support is provided using the excellent "DataTables":http://www.datatables.net jQuery plugin.

h2. Database table definitions

The structure of the table definitions in the database is pretty straightforward.  A TableOwner has multiple TableModels, and each TableModel has 0 or more TableColumns.  The tricky part about this is JPA's problem with interfaces, so in order to make your users table-owners, you'll need to add a TableOwner field to your user entity - this is a straightforward one-to-one mapping.

bc. @OneToOne(cascade = CascadeType.ALL)
public TableOwner tableOwner;

Once you've done this, you can create table models for the table owner.

h2. The table model

A table model represents a table owner's configuration for a specific table in your application.  It's essentially an aggregation of table columns plus key information - the view ID, the table ID and the table owner.

h3. View IDs

View IDs are linked to a single screen which may contain one or more tables.  Think of a view ID as a namespace, allowing tables to reuse table IDs when you feel like it.

h3. Table IDs

Table IDs identify individual tables within a view.  Each table within a view has a unique ID, allowing it to have a unique configuration.

h3. Table owners

A table owner can have multiple table models, but the combination of table owner plus view ID plus table ID is unique.

h3. Table models are not necessary!

Despite everything written above, it's perfectly possible to use Tabula Rasa without table models.  Personalized table models are only useful if you're creating a web app with identifiable users - if you're not doing this, you can still use Tabula Rasa to give you integration with DataTables so that, for example, AJAX delivery of content is simplified.

h2. Table columns

A table column represents a single column in your table model.  It has a key, a position, a flag to indicate if it's visible and another to indicate if it's mandatory.

h2. Creating table models

Assuming you've already integrated TableOwner into your user entity, you're now ready to create personalized tables.  In your controller, you need to define between one and three String arrays in order to create the factory-default view of the table- the visible columns, all the columns and the mandatory columns.

h3. Visible columns

Visible columns are required, because they define what the user sees the very first time the table is used.  The contents of the array define the column keys and their intial order.

bc. private static final String[] VISIBLE_COLUMNS = {"name", "location"};

A table model initialised with this array would contain two columns - both would be visible, neither would be mandatory and the order would be "name" and "location".

To retrieve a table mode, and create a one if it doesn't exist, you can use the TableController:

bc. TableModel tableModel = TableController.getTableModel(user.tableOwner,
                                                      VIEW_ID,
                                                      TABLE_ID,
                                                      VISIBLE_COLUMNS);

Using this method, VISIBLE_COLUMNS is taken to define ALL_COLUMNS too.

h3.All columns

It's possible that your table contains so many columns that it would be a UI nightmare to show them all at once.  In this scenario, you can define all your columns, and then define the ones your want to be visible:

bc. private static final String[] VISIBLE_COLUMNS = {"location", "foo"};
private static final String[] ALL_COLUMNS = {"name", "location", "foo", "bar"};

And then create the table model:

bc. TableModel tableModel = TableController.getTableModel(user.tableOwner,
                                                      VIEW_ID,
                                                      TABLE_ID,
                                                      VISIBLE_COLUMNS,
                                                      ALL_COLUMNS);

A table model initialised with these arrays would contain four columns - the union of ALL_COLUMNS and VISIBLE_COLUMNS would be visible, none would be mandatory and the order would be "name", "location", "foo" and "bar".

h3. Mandatory columns

If there is a case where you want to mark a column as always visible, you can set the mandatory flag in the same manner as above.

bc. private static final String[] VISIBLE_COLUMNS = {"location", "foo"};
private static final String[] ALL_COLUMNS = {"name", "location", "foo", "bar"};
private static final String[] MANDATORY_COLUMNS = {"name", "foo"};

A table model initialised with these arrays would contain four columns - the union of ALL_COLUMNS and VISIBLE_COLUMNS would be visible, any column marked as mandatory would be flagged as both mandatory and visible - even if it didn't appear in VISIBLE_COLUMNS,  and the order would be "name", "location", "foo" and "bar".


h2. The name

Tabula Rasa is designed to help you work with tables, so I named it after a Buffy the Vampire Slayer that may have featured a table at some point.